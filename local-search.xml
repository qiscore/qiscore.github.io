<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>实战Nginx</title>
    <link href="/2023/12/09/books/%E5%AE%9E%E6%88%98Nginx/"/>
    <url>/2023/12/09/books/%E5%AE%9E%E6%88%98Nginx/</url>
    
    <content type="html"><![CDATA[<embed src="/books/实战Nginx取代Apache的高性能Web服务器.pdf" type="application/pdf" width="100%" height="900">]]></content>
    
    
    <categories>
      
      <category>书单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch权威指南</title>
    <link href="/2023/12/09/books/Elasticsearch%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <url>/2023/12/09/books/Elasticsearch%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<embed src="/books/Elasticsearch权威指南.pdf" type="application/pdf" width="100%" height="900">]]></content>
    
    
    <categories>
      
      <category>书单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java虚拟机</title>
    <link href="/2023/12/09/books/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2023/12/09/books/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<embed src="/books/深入理解Java虚拟机：JVM高级特性与最佳实践.pdf" type="application/pdf" width="100%" height="900">]]></content>
    
    
    <categories>
      
      <category>书单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bean的生命周期</title>
    <link href="/2023/12/09/spring/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2023/12/09/spring/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们没有使用Spring框架之前，创建对象一般都是使用new关键字进行创建，当然除了new关键字外，还有</p><ul><li>运用反射手段，使用Class类的newInstance方法 或者 Constructor类中的newInstance方法</li><li>使用clone方法</li><li>使用反序列化（ObjectInputStream）</li></ul><p>一旦对象不再被使用的时候，将有可能被JVM垃圾回收器进行回收。</p><p>但是在Spring通过IOC容器进行管理之后，Bean 的生命周期就变得更加复杂了，下图展示了Bean的构造过程</p><p><img src="/images/spring/image-20200614155732584.png" alt="image-20200614155732584"></p><h2 id="Bean的生命周期-1"><a href="#Bean的生命周期-1" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>我们对上图的每个步骤进行文字说明</p><ul><li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li><li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li><li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li><li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li><li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li><li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li><li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li><li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li><li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li></ul><h2 id="接口方法的分类"><a href="#接口方法的分类" class="headerlink" title="接口方法的分类"></a>接口方法的分类</h2><p> Bean的完整生命周期经历了各种方法的调用，这些方法可以分类一下三类</p><h3 id="Bean自身的方法："><a href="#Bean自身的方法：" class="headerlink" title="Bean自身的方法："></a>Bean自身的方法：</h3><p>这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</p><h3 id="Bean级生命周期的方法"><a href="#Bean级生命周期的方法" class="headerlink" title="Bean级生命周期的方法"></a>Bean级生命周期的方法</h3><p>这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</p><h3 id="容器级生命周期的方法"><a href="#容器级生命周期的方法" class="headerlink" title="容器级生命周期的方法"></a>容器级生命周期的方法</h3><p>这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p><h3 id="工程后处理器接口方法"><a href="#工程后处理器接口方法" class="headerlink" title="工程后处理器接口方法"></a>工程后处理器接口方法</h3><p>这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器　　接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p><h2 id="DEMO举例"><a href="#DEMO举例" class="headerlink" title="DEMO举例"></a>DEMO举例</h2><p>我们用一个简单的Spring Bean来演示一下Spring Bean的生命周期。</p><p>首先是一个简单的Spring Bean，调用Bean自身的方法和Bean级生命周期接口方法，为了方便演示，它实现了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这4个接口，同时有2个方法，对应配置文件中<bean>的init-method和destroy-method。如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package springBeanTest;<br><br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">BeansException</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">BeanFactory</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">BeanFactoryAware</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">BeanNameAware</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">DisposableBean</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">InitializingBean</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryAware</span>, <span class="hljs-title class_">BeanNameAware</span>,<br>        <span class="hljs-title class_">InitializingBean</span>, <span class="hljs-title class_">DisposableBean</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> address;<br>    <span class="hljs-keyword">private</span> int phone;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">BeanFactory</span> beanFactory;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> beanName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Person</span>() &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;【构造器】调用Person的构造器实例化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;【注入属性】注入属性name&quot;</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAddress</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAddress</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> address</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;【注入属性】注入属性address&quot;</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> int <span class="hljs-title function_">getPhone</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> phone;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setPhone</span>(<span class="hljs-params">int phone</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;【注入属性】注入属性phone&quot;</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">phone</span> = phone;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person [address=&quot;</span> + address + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;, phone=&quot;</span><br>                + phone + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 这是BeanFactoryAware接口方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setBeanFactory</span>(<span class="hljs-title class_">BeanFactory</span> arg0) throws <span class="hljs-title class_">BeansException</span> &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span><br>                .<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()&quot;</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">beanFactory</span> = arg0;<br>    &#125;<br><br>    <span class="hljs-comment">// 这是BeanNameAware接口方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setBeanName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> arg0</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;【BeanNameAware接口】调用BeanNameAware.setBeanName()&quot;</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">beanName</span> = arg0;<br>    &#125;<br><br>    <span class="hljs-comment">// 这是InitializingBean接口方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">afterPropertiesSet</span>() throws <span class="hljs-title class_">Exception</span> &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span><br>                .<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;【InitializingBean接口】调用InitializingBean.afterPropertiesSet()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 这是DiposibleBean接口方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">destroy</span>() throws <span class="hljs-title class_">Exception</span> &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;【DiposibleBean接口】调用DiposibleBean.destory()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过&lt;bean&gt;的init-method属性指定的初始化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myInit</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过&lt;bean&gt;的destroy-method属性指定的初始化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myDestory</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是演示BeanPostProcessor接口的方法，如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> springBeanTest;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBeanPostProcessor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;这是BeanPostProcessor实现类构造器！！&quot;</span>);<br>        <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object arg0, String arg1)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out<br>        .println(<span class="hljs-string">&quot;BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！&quot;</span>);<br>        <span class="hljs-keyword">return</span> arg0;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object arg0, String arg1)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out<br>        .println(<span class="hljs-string">&quot;BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！&quot;</span>);<br>        <span class="hljs-keyword">return</span> arg0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，BeanPostProcessor接口包括2个方法postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。这里要注意。</p><p>InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口，一般我们继承Spring为其提供的适配器类InstantiationAwareBeanPostProcessor Adapter来使用它，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> springBeanTest;<br><br><span class="hljs-keyword">import</span> java.beans.PropertyDescriptor;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.PropertyValues;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">extends</span><br>        <span class="hljs-title class_">InstantiationAwareBeanPostProcessorAdapter</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInstantiationAwareBeanPostProcessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        System.out<br>                .println(<span class="hljs-string">&quot;这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 接口方法、实例化Bean之前调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInstantiation</span><span class="hljs-params">(Class beanClass,</span><br><span class="hljs-params">            String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out<br>                .println(<span class="hljs-string">&quot;InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接口方法、实例化Bean之后调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span><br>            <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out<br>                .println(<span class="hljs-string">&quot;InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-comment">// 接口方法、设置某个属性时调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title function_">postProcessPropertyValues</span><span class="hljs-params">(PropertyValues pvs,</span><br><span class="hljs-params">            PropertyDescriptor[] pds, Object bean, String beanName)</span><br>            <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out<br>                .println(<span class="hljs-string">&quot;InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> pvs;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></p><p><a href="https://www.cnblogs.com/javazhiyin/p/10905294.html">https://www.cnblogs.com/javazhiyin/p/10905294.html</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020最新Java面试题及答案</title>
    <link href="/2023/12/09/books/2020%E6%9C%80%E6%96%B0Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    <url>/2023/12/09/books/2020%E6%9C%80%E6%96%B0Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<embed src="/books/2020最新Java面试题及答案.pdf" type="application/pdf" width="100%" height="900">]]></content>
    
    
    <categories>
      
      <category>书单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试宝典</title>
    <link href="/2023/12/09/books/java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    <url>/2023/12/09/books/java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<embed src="/books/Java面试宝典.pdf" type="application/pdf" width="100%" height="900">]]></content>
    
    
    <categories>
      
      <category>书单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubesphere环境安装</title>
    <link href="/2023/12/09/k8s/kubesphere%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <url>/2023/12/09/k8s/kubesphere%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>集群规划<br>master: 172.20.10.2  root&#x2F;root<br>slave: 172.20.10.3   root&#x2F;root</p></blockquote><h1 id="1-kubesphere环境初始化"><a href="#1-kubesphere环境初始化" class="headerlink" title="1. kubesphere环境初始化"></a>1. kubesphere环境初始化</h1><h2 id="1-准备初始化脚本initial-kube-sh"><a href="#1-准备初始化脚本initial-kube-sh" class="headerlink" title="1. 准备初始化脚本initial_kube.sh"></a>1. 准备初始化脚本initial_kube.sh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;--------------------step-1 初始化环境-------------------------&quot;<br>echo &quot;设置节点的hostname&quot;<br>node_hostname=$1<br>hostnamectl set-hostname $node_hostname<br><br>echo &quot;将 SELinux 设置为 permissive 模式（相当于将其禁用）&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 SELinux 设置为 permissive 模式（相当于将其禁用）</span><br>sudo setenforce 0<br>sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config<br><br>echo &quot;关闭swap&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">关闭swap</span><br>swapoff -a  <br>sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab<br><br>echo &quot;允许 iptables 检查桥接流量&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">允许 iptables 检查桥接流量</span><br>cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf<br>br_netfilter<br>EOF<br><br>cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf<br>net.bridge.bridge-nf-call-ip6tables = 1<br>net.bridge.bridge-nf-call-iptables = 1<br>EOF<br>sudo sysctl --system<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">放行端口</span><br>sudo tee ./turnon-port.sh &lt;&lt;-&#x27;EOF&#x27;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">打开端口</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;Open firewall port $1&quot;<br>firewall-cmd --zone=public --add-port=$1/tcp --permanent<br>firewall-cmd --reload<br>firewall-cmd --zone=public --list-ports<br>EOF<br>chmod 755 ./turnon-port.sh<br>sh ./turnon-port.sh 80-32796<br>iptables -P INPUT ACCEPT<br>iptables -P FORWARD ACCEPT<br>iptables -P OUTPUT ACCEPT<br>iptables -F<br>systemctl stop firewalld.service<br>systemctl disable firewalld.service<br>systemctl restart docker<br><span class="hljs-meta prompt_">#</span><span class="language-bash">更新系统时间</span><br>echo &quot;同步系统时间&quot;<br>yum install ntpdate -y<br>ntpdate ntp1.aliyun.com<br><br></code></pre></td></tr></table></figure><h2 id="2-集群的每个节点执行脚本"><a href="#2-集群的每个节点执行脚本" class="headerlink" title="2. 集群的每个节点执行脚本"></a>2. 集群的每个节点执行脚本</h2><p><code> sh initial_kube.sh master</code><br><code> sh initial_kube.sh slave</code></p><h1 id="2-kubesphere-yaml配置文件"><a href="#2-kubesphere-yaml配置文件" class="headerlink" title="2. kubesphere.yaml配置文件"></a>2. kubesphere.yaml配置文件</h1><h2 id="1-方式1：直接使用以下配置文件"><a href="#1-方式1：直接使用以下配置文件" class="headerlink" title="1. 方式1：直接使用以下配置文件"></a>1. 方式1：直接使用以下配置文件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubekey.kubesphere.io/v1alpha2</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Cluster</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">sample</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hosts:</span><br>  <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">master</span>, <span class="hljs-attr">address:</span> <span class="hljs-number">172.20</span><span class="hljs-number">.10</span><span class="hljs-number">.2</span>, <span class="hljs-attr">internalAddress:</span> <span class="hljs-number">172.20</span><span class="hljs-number">.10</span><span class="hljs-number">.2</span>, <span class="hljs-attr">user:</span> <span class="hljs-string">root</span>, <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;root&quot;</span>&#125;<br>  <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">slave</span>, <span class="hljs-attr">address:</span> <span class="hljs-number">172.20</span><span class="hljs-number">.10</span><span class="hljs-number">.3</span>, <span class="hljs-attr">internalAddress:</span> <span class="hljs-number">172.20</span><span class="hljs-number">.10</span><span class="hljs-number">.3</span>, <span class="hljs-attr">user:</span> <span class="hljs-string">root</span>, <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;root&quot;</span>&#125;<br>  <span class="hljs-attr">roleGroups:</span><br>    <span class="hljs-attr">etcd:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br>    <span class="hljs-attr">control-plane:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br>    <span class="hljs-attr">worker:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">slave</span><br>  <span class="hljs-attr">controlPlaneEndpoint:</span><br>    <span class="hljs-comment">## Internal loadbalancer for apiservers </span><br>    <span class="hljs-comment"># internalLoadbalancer: haproxy</span><br><br>    <span class="hljs-attr">domain:</span> <span class="hljs-string">lb.kubesphere.local</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6443</span><br>  <span class="hljs-attr">kubernetes:</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-number">1.22</span><span class="hljs-number">.10</span><br>    <span class="hljs-attr">clusterName:</span> <span class="hljs-string">cluster.local</span><br>    <span class="hljs-attr">autoRenewCerts:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">containerManager:</span> <span class="hljs-string">docker</span><br>  <span class="hljs-attr">etcd:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">kubekey</span><br>  <span class="hljs-attr">network:</span><br>    <span class="hljs-attr">plugin:</span> <span class="hljs-string">calico</span><br>    <span class="hljs-attr">kubePodsCIDR:</span> <span class="hljs-number">10.233</span><span class="hljs-number">.64</span><span class="hljs-number">.0</span><span class="hljs-string">/18</span><br>    <span class="hljs-attr">kubeServiceCIDR:</span> <span class="hljs-number">10.233</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/18</span><br>    <span class="hljs-comment">## multus support. https://github.com/k8snetworkplumbingwg/multus-cni</span><br>    <span class="hljs-attr">multusCNI:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">privateRegistry:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">namespaceOverride:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">registryMirrors:</span> []<br>    <span class="hljs-attr">insecureRegistries:</span> []<br>  <span class="hljs-attr">addons:</span> []<br><br><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">installer.kubesphere.io/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterConfiguration</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ks-installer</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubesphere-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-number">3.3</span><span class="hljs-number">.0</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">persistence:</span><br>    <span class="hljs-attr">storageClass:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">authentication:</span><br>    <span class="hljs-attr">jwtSecret:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">zone:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">local_registry:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">namespace_override:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-comment"># dev_tag: &quot;&quot;</span><br>  <span class="hljs-attr">etcd:</span><br>    <span class="hljs-attr">monitoring:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">endpointIps:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">2379</span><br>    <span class="hljs-attr">tlsEnable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">common:</span><br>    <span class="hljs-attr">core:</span><br>      <span class="hljs-attr">console:</span><br>        <span class="hljs-attr">enableMultiLogin:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">30880</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>    <span class="hljs-comment"># apiserver:</span><br>    <span class="hljs-comment">#  resources: &#123;&#125;</span><br>    <span class="hljs-comment"># controllerManager:</span><br>    <span class="hljs-comment">#  resources: &#123;&#125;</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">volumeSize:</span> <span class="hljs-string">2Gi</span><br>    <span class="hljs-attr">openldap:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">volumeSize:</span> <span class="hljs-string">2Gi</span><br>    <span class="hljs-attr">minio:</span><br>      <span class="hljs-attr">volumeSize:</span> <span class="hljs-string">20Gi</span><br>    <span class="hljs-attr">monitoring:</span><br>      <span class="hljs-comment"># type: external</span><br>      <span class="hljs-attr">endpoint:</span> <span class="hljs-string">http://prometheus-operated.kubesphere-monitoring-system.svc:9090</span><br>      <span class="hljs-attr">GPUMonitoring:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">gpu:</span><br>      <span class="hljs-attr">kinds:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">resourceName:</span> <span class="hljs-string">&quot;nvidia.com/gpu&quot;</span><br>        <span class="hljs-attr">resourceType:</span> <span class="hljs-string">&quot;GPU&quot;</span><br>        <span class="hljs-attr">default:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">es:</span><br>      <span class="hljs-comment"># master:</span><br>      <span class="hljs-comment">#   volumeSize: 4Gi</span><br>      <span class="hljs-comment">#   replicas: 1</span><br>      <span class="hljs-comment">#   resources: &#123;&#125;</span><br>      <span class="hljs-comment"># data:</span><br>      <span class="hljs-comment">#   volumeSize: 20Gi</span><br>      <span class="hljs-comment">#   replicas: 1</span><br>      <span class="hljs-comment">#   resources: &#123;&#125;</span><br>      <span class="hljs-attr">logMaxAge:</span> <span class="hljs-number">7</span><br>      <span class="hljs-attr">elkPrefix:</span> <span class="hljs-string">logstash</span><br>      <span class="hljs-attr">basicAuth:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">externalElasticsearchHost:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">externalElasticsearchPort:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">alerting:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># thanosruler:</span><br>    <span class="hljs-comment">#   replicas: 1</span><br>    <span class="hljs-comment">#   resources: &#123;&#125;</span><br>  <span class="hljs-attr">auditing:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># operator:</span><br>    <span class="hljs-comment">#   resources: &#123;&#125;</span><br>    <span class="hljs-comment"># webhook:</span><br>    <span class="hljs-comment">#   resources: &#123;&#125;</span><br>  <span class="hljs-attr">devops:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># resources: &#123;&#125;</span><br>    <span class="hljs-attr">jenkinsMemoryLim:</span> <span class="hljs-string">2Gi</span><br>    <span class="hljs-attr">jenkinsMemoryReq:</span> <span class="hljs-string">1500Mi</span><br>    <span class="hljs-attr">jenkinsVolumeSize:</span> <span class="hljs-string">8Gi</span><br>    <span class="hljs-attr">jenkinsJavaOpts_Xms:</span> <span class="hljs-string">1200m</span><br>    <span class="hljs-attr">jenkinsJavaOpts_Xmx:</span> <span class="hljs-string">1600m</span><br>    <span class="hljs-attr">jenkinsJavaOpts_MaxRAM:</span> <span class="hljs-string">2g</span><br>  <span class="hljs-attr">events:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># operator:</span><br>    <span class="hljs-comment">#   resources: &#123;&#125;</span><br>    <span class="hljs-comment"># exporter:</span><br>    <span class="hljs-comment">#   resources: &#123;&#125;</span><br>    <span class="hljs-comment"># ruler:</span><br>    <span class="hljs-comment">#   enabled: true</span><br>    <span class="hljs-comment">#   replicas: 2</span><br>    <span class="hljs-comment">#   resources: &#123;&#125;</span><br>  <span class="hljs-attr">logging:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">logsidecar:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>      <span class="hljs-comment"># resources: &#123;&#125;</span><br>  <span class="hljs-attr">metrics_server:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">monitoring:</span><br>    <span class="hljs-attr">storageClass:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">node_exporter:</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">9100</span><br>      <span class="hljs-comment"># resources: &#123;&#125;</span><br>    <span class="hljs-comment"># kube_rbac_proxy:</span><br>    <span class="hljs-comment">#   resources: &#123;&#125;</span><br>    <span class="hljs-comment"># kube_state_metrics:</span><br>    <span class="hljs-comment">#   resources: &#123;&#125;</span><br>    <span class="hljs-comment"># prometheus:</span><br>    <span class="hljs-comment">#   replicas: 1</span><br>    <span class="hljs-comment">#   volumeSize: 20Gi</span><br>    <span class="hljs-comment">#   resources: &#123;&#125;</span><br>    <span class="hljs-comment">#   operator:</span><br>    <span class="hljs-comment">#     resources: &#123;&#125;</span><br>    <span class="hljs-comment"># alertmanager:</span><br>    <span class="hljs-comment">#   replicas: 1</span><br>    <span class="hljs-comment">#   resources: &#123;&#125;</span><br>    <span class="hljs-comment"># notification_manager:</span><br>    <span class="hljs-comment">#   resources: &#123;&#125;</span><br>    <span class="hljs-comment">#   operator:</span><br>    <span class="hljs-comment">#     resources: &#123;&#125;</span><br>    <span class="hljs-comment">#   proxy:</span><br>    <span class="hljs-comment">#     resources: &#123;&#125;</span><br>    <span class="hljs-attr">gpu:</span><br>      <span class="hljs-attr">nvidia_dcgm_exporter:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-comment"># resources: &#123;&#125;</span><br>  <span class="hljs-attr">multicluster:</span><br>    <span class="hljs-attr">clusterRole:</span> <span class="hljs-string">none</span><br>  <span class="hljs-attr">network:</span><br>    <span class="hljs-attr">networkpolicy:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">ippool:</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">none</span><br>    <span class="hljs-attr">topology:</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">none</span><br>  <span class="hljs-attr">openpitrix:</span><br>    <span class="hljs-attr">store:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">servicemesh:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">istio:</span><br>      <span class="hljs-attr">components:</span><br>        <span class="hljs-attr">ingressGateways:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">istio-ingressgateway</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-attr">cni:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">edgeruntime:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">kubeedge:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">cloudCore:</span><br>        <span class="hljs-attr">cloudHub:</span><br>          <span class="hljs-attr">advertiseAddress:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">service:</span><br>          <span class="hljs-attr">cloudhubNodePort:</span> <span class="hljs-string">&quot;30000&quot;</span><br>          <span class="hljs-attr">cloudhubQuicNodePort:</span> <span class="hljs-string">&quot;30001&quot;</span><br>          <span class="hljs-attr">cloudhubHttpsNodePort:</span> <span class="hljs-string">&quot;30002&quot;</span><br>          <span class="hljs-attr">cloudstreamNodePort:</span> <span class="hljs-string">&quot;30003&quot;</span><br>          <span class="hljs-attr">tunnelNodePort:</span> <span class="hljs-string">&quot;30004&quot;</span><br>        <span class="hljs-comment"># resources: &#123;&#125;</span><br>        <span class="hljs-comment"># hostNetWork: false</span><br>      <span class="hljs-attr">iptables-manager:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">mode:</span> <span class="hljs-string">&quot;external&quot;</span><br>        <span class="hljs-comment"># resources: &#123;&#125;</span><br>      <span class="hljs-comment"># edgeService:</span><br>      <span class="hljs-comment">#   resources: &#123;&#125;</span><br>  <span class="hljs-attr">terminal:</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">600</span><br><br></code></pre></td></tr></table></figure><h2 id="2-方式2：使用kubekey生成kubesphere-yaml"><a href="#2-方式2：使用kubekey生成kubesphere-yaml" class="headerlink" title="2. 方式2：使用kubekey生成kubesphere.yaml"></a>2. 方式2：使用kubekey生成kubesphere.yaml</h2><h3 id="1-准备脚本install-kk-config-sh"><a href="#1-准备脚本install-kk-config-sh" class="headerlink" title="1. 准备脚本install-kk-config.sh"></a>1. 准备脚本install-kk-config.sh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>export KKZONE=cn<br>curl -sfL https://get-kk.kubesphere.io | VERSION=v3.0.2 sh -<br>chmod 777 ./kk<br>echo &quot;安装kubesphare运行时依赖...&quot;<br>yum install -y openssl openssl-devel socat epel-release conntrack-tools <br><br>./kk create config --with-kubernetes v1.20.4 --with-kubesphere v3.1.1<br><br>mv config-sample.yaml kubesphere.yaml<br><br></code></pre></td></tr></table></figure><h3 id="2-执行脚本install-kk-config-sh"><a href="#2-执行脚本install-kk-config-sh" class="headerlink" title="2. 执行脚本install-kk-config.sh"></a>2. 执行脚本install-kk-config.sh</h3><p><code>sh install-kk-config.sh</code></p><blockquote><p>注意： 生成kubesphere.yaml后，要编辑此文件，将host属性部分改为自己集群的节点ip</p></blockquote><h1 id="3-安装kubesphere集群"><a href="#3-安装kubesphere集群" class="headerlink" title="3. 安装kubesphere集群"></a>3. 安装kubesphere集群</h1><h2 id="1-如果没有kubekey，先安装kubekey"><a href="#1-如果没有kubekey，先安装kubekey" class="headerlink" title="1. 如果没有kubekey，先安装kubekey"></a>1. 如果没有kubekey，先安装kubekey</h2><p>(1). 准备脚本install-kk.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>export KKZONE=cn<br>curl -sfL https://get-kk.kubesphere.io | VERSION=v3.0.2 sh -<br>chmod 777 ./kk<br>echo &quot;安装kubesphare运行时依赖...&quot;<br>yum install -y openssl openssl-devel socat epel-release conntrack-tools <br></code></pre></td></tr></table></figure><p>(2). 执行脚本install-kk.sh<br><code>sh install-kk.sh</code></p><h2 id="2-安装kubesphere"><a href="#2-安装kubesphere" class="headerlink" title="2. 安装kubesphere"></a>2. 安装kubesphere</h2><p>.&#x2F;kk create cluster -f kubesphere.yaml</p><h2 id="3-查看安装进度"><a href="#3-查看安装进度" class="headerlink" title="3. 查看安装进度"></a>3. 查看安装进度</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l app=ks-install -o jsonpath=&#x27;&#123;.items[0].metadata.name&#125;&#x27;) -f<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker常用容器创建</title>
    <link href="/2023/12/09/docker/docker%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA/"/>
    <url>/2023/12/09/docker/docker%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-MySQL"><a href="#1-MySQL" class="headerlink" title="1. MySQL"></a>1. MySQL</h1><h2 id="1-准备mysql配置文件my-cnf"><a href="#1-准备mysql配置文件my-cnf" class="headerlink" title="1. 准备mysql配置文件my.cnf"></a>1. 准备mysql配置文件my.cnf</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[client]<br>default-character-set = utf8mb4<br><br>[mysql]<br>default-character-set = utf8mb4<br><br>[mysqld]<br>character-set-client-handshake = FALSE<br>character-set-server = utf8mb4<br>collation-server = utf8mb4_unicode_ci<br>init_connect=&#x27;SET NAMES utf8mb4&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">默认时区配置</span><br>default-time_zone = &#x27;+8:00&#x27; <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置数据库支持分组</span><br>sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION<br><span class="hljs-meta prompt_">#</span><span class="language-bash">表名不区分大小写</span><br>lower_case_table_names=1<br><br></code></pre></td></tr></table></figure><h2 id="2-准备容器创建脚本mysql-install-docker-sh"><a href="#2-准备容器创建脚本mysql-install-docker-sh" class="headerlink" title="2. 准备容器创建脚本mysql-install-docker.sh"></a>2. 准备容器创建脚本mysql-install-docker.sh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>docker_root=/usr/local/software/docker<br>mysql_dir=$docker_root/mysql<br>config_dir=$mysql_dir/config<br>data_dir=$mysql_dir/data<br>logs_dir=$mysql_dir/logs<br><br>echo &quot;创建数据目录&quot;<br>mkdir -p $config_dir<br>mkdir -p $data_dir<br><br>mv ./my.cnf $config_dir<br>chmod -R 755 $docker_root<br><br>echo &quot;开始拉取MySQL5.7镜像&quot;<br>docker pull mysql:5.7<br><br>echo &quot;创建容器&quot;<br><br>docker run -d -p 3306:3306 --privileged=true \<br>-v $config_dir/my.cnf:/etc/mysql/my.cnf \<br>-v $data_dir:/var/lib/mysql \<br>-v $logs_dir:/logs \<br>-e MYSQL_ROOT_PASSWORD=root \<br>--name mysql mysql:5.7<br><br>echo &quot;容器创建完成&quot;<br>docker ps | grep &quot;mysql&quot;<br><br>mv ./mysql-install-docker.sh $mysql_dir<br><br></code></pre></td></tr></table></figure><h2 id="3-执行脚本"><a href="#3-执行脚本" class="headerlink" title="3. 执行脚本"></a>3. 执行脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh mysql-install-docker.sh<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell常用脚本</title>
    <link href="/2023/12/09/shell/shell%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/12/09/shell/shell%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装java环境"><a href="#1-安装java环境" class="headerlink" title="1. 安装java环境"></a>1. 安装java环境</h1><h2 id="1-准备jdk安装包，environment-txt-环境变量配置文件"><a href="#1-准备jdk安装包，environment-txt-环境变量配置文件" class="headerlink" title="1. 准备jdk安装包，environment.txt 环境变量配置文件"></a>1. 准备jdk安装包，environment.txt 环境变量配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br><br>export JAVA_HOME=/usr/local/software/jdk1.8.0_231<br>export PATH=$PATH:$JAVA_HOME/bin<br>export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br>export JRE_HOME=$JAVA_HOME/jre<br><br><br></code></pre></td></tr></table></figure><h2 id="2-准备脚本jdk-install-sh"><a href="#2-准备脚本jdk-install-sh" class="headerlink" title="2. 准备脚本jdk-install.sh"></a>2. 准备脚本jdk-install.sh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo &quot;解压jdk&quot;<br>tar -zxvf jdk-8u231-linux-x64.tar.gz<br><br>cat environment.txt &gt;&gt; ~/.bash_profile<br>source ~/.bash_profile<br>java -version<br><br><br></code></pre></td></tr></table></figure><h2 id="3-执行脚本"><a href="#3-执行脚本" class="headerlink" title="3. 执行脚本"></a>3. 执行脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh jdk-install.sh<br><br></code></pre></td></tr></table></figure><h1 id="2-安装nginx"><a href="#2-安装nginx" class="headerlink" title="2. 安装nginx"></a>2. 安装nginx</h1><h2 id="1-准备脚本nginx-install-sh"><a href="#1-准备脚本nginx-install-sh" class="headerlink" title="1. 准备脚本nginx-install.sh"></a>1. 准备脚本nginx-install.sh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>software_dir=/usr/local/software<br>nginx_dir=$software_dir/nginx<br>mkdir -p $nginx_dir<br>chmod -R 755 $nginx_dir<br><br>cd $nginx_dir <br><br>echo &quot;安装依赖包&quot;<br>yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel wget<br>wget http://nginx.org/download/nginx-1.23.2.tar.gz<br><br>tar -xvf nginx-1.23.2.tar.gz<br><br>cd $nginx_dir/nginx-1.23.2<br><br>echo &quot;安装SSL模块&quot;<br>./configure --prefix=$nginx_dir --with-http_stub_status_module --with-http_ssl_module<br><br>make<br>make install<br><br><br>echo &quot;创建启动脚本&quot;<br><br>tee $nginx_dir/startup.sh &lt;&lt;-&#x27;EOF&#x27;<br><br>software_dir=/usr/local/software<br>nginx_dir=$software_dir/nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">nginx_dir/sbin/nginx -c <span class="hljs-variable">$nginx_dir</span>/conf/nginx.conf</span><br><br>EOF<br><br>chmod 755 $nginx_dir/startup.sh<br><br>echo &quot;创建停止脚本&quot;<br>tee $nginx_dir/stop.sh &lt;&lt;-&#x27;EOF&#x27;<br><br>software_dir=/usr/local/software<br>nginx_dir=$software_dir/nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">nginx_dir/sbin/nginx -s stop</span><br><br>EOF<br>   <br>chmod 755 $nginx_dir/stop.sh<br><br><br>echo &quot;创建重启脚本&quot;<br>tee $nginx_dir/restart.sh &lt;&lt;-&#x27;EOF&#x27;<br><br>sh stop.sh<br>sh startup.sh<br><br>EOF<br><br>chmod 755 $nginx_dir/restart.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">在文件首行插入内容</span><br>sed -i &#x27;1i\#!/bin/bash&#x27; $nginx_dir/*.sh<br><br>mv $software_dir/nginx-install.sh $nginx_dir<br><br>echo &quot;开放tcp/ip端口80-25535&quot;<br>firewall-cmd --zone=public --add-port=80-25535/tcp --permanent<br>firewall-cmd --reload<br><br></code></pre></td></tr></table></figure><h2 id="2-执行脚本"><a href="#2-执行脚本" class="headerlink" title="2 . 执行脚本"></a>2 . 执行脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh nginx-install.sh<br><br></code></pre></td></tr></table></figure><h1 id="3-安装docker"><a href="#3-安装docker" class="headerlink" title="3. 安装docker"></a>3. 安装docker</h1><h2 id="1-准备脚本docker-install-sh"><a href="#1-准备脚本docker-install-sh" class="headerlink" title="1.  准备脚本docker-install.sh"></a>1.  准备脚本docker-install.sh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>sudo yum remove docker*<br>echo &quot;安装必要软件包&quot;<br><br>sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br><br>echo &quot;Step 2: 添加软件源信息&quot;<br>sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>sudo sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo<br>echo &quot;更新并安装Docker-CE-20.10.17&quot;<br>sudo yum makecache fast<br>sudo yum -y install docker-ce-20.10.12-3.el7<br>echo &quot;设置开机启动&quot;<br>systemctl enable docker --now<br>echo &quot;配置镜像加速器&quot;<br>sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;<br>&#123;<br> &quot;registry-mirrors&quot;: [&quot;https://y96pbacg.mirror.aliyuncs.com&quot;]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br><span class="hljs-meta prompt_">#</span><span class="language-bash">更新系统时间</span><br>echo &quot;同步系统时间&quot;<br>yum install ntpdate -y<br>ntpdate cn.pool.ntp.org<br><br><br></code></pre></td></tr></table></figure><h2 id="2-执行脚本-1"><a href="#2-执行脚本-1" class="headerlink" title="2. 执行脚本"></a>2. 执行脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh docker-install.sh<br><br></code></pre></td></tr></table></figure><h1 id="4-安装k8s集群"><a href="#4-安装k8s集群" class="headerlink" title="4. 安装k8s集群"></a>4. 安装k8s集群</h1><h2 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1 . 安装docker"></a>1 . 安装docker</h2><p>略</p><h2 id="2-规划集群节点"><a href="#2-规划集群节点" class="headerlink" title="2. 规划集群节点"></a>2. 规划集群节点</h2><p>主节点master：172.20.10.2<br>从节点slave：172.20.10.4</p><h2 id="3-准备脚本k8s-install-sh"><a href="#3-准备脚本k8s-install-sh" class="headerlink" title="3. 准备脚本k8s-install.sh"></a>3. 准备脚本k8s-install.sh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;--------------------step-1 初始化环境-------------------------&quot;<br>echo &quot;设置节点的hostname&quot;<br>node_hostname=$1<br>hostnamectl set-hostname $node_hostname<br><br>echo &quot;将 SELinux 设置为 permissive 模式（相当于将其禁用）&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 SELinux 设置为 permissive 模式（相当于将其禁用）</span><br>sudo setenforce 0<br>sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config<br><br>echo &quot;关闭swap&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">关闭swap</span><br>swapoff -a  <br>sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab<br><br>echo &quot;允许 iptables 检查桥接流量&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">允许 iptables 检查桥接流量</span><br>cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf<br>br_netfilter<br>EOF<br><br>cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf<br>net.bridge.bridge-nf-call-ip6tables = 1<br>net.bridge.bridge-nf-call-iptables = 1<br>EOF<br>sudo sysctl --system<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">放行端口</span><br>sudo tee ./turnon-port.sh &lt;&lt;-&#x27;EOF&#x27;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">打开端口</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;Open firewall port $1&quot;<br>firewall-cmd --zone=public --add-port=$1/tcp --permanent<br>firewall-cmd --reload<br>firewall-cmd --zone=public --list-ports<br>EOF<br>chmod 755 ./turnon-port.sh<br>sh ./turnon-port.sh 30000-32796<br>iptables -P INPUT ACCEPT<br>iptables -P FORWARD ACCEPT<br>iptables -P OUTPUT ACCEPT<br>iptables -F<br>systemctl restart docker<br><span class="hljs-meta prompt_">#</span><span class="language-bash">更新系统时间</span><br>echo &quot;同步系统时间&quot;<br>yum install ntpdate -y<br>ntpdate cn.pool.ntp.org<br><br>rm -rf /etc/containerd/config.toml<br>systemctl restart containerd<br><br>echo &quot;--------------------step-2 安装kubelet、kubeadm、kubectl-------------------------&quot;<br><br>cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo<br>[kubernetes]<br>name=Kubernetes<br>baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64<br>enabled=1<br>gpgcheck=0<br>repo_gpgcheck=0<br>gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg<br>   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg<br>exclude=kubelet kubeadm kubectl<br>EOF<br><br><br>sudo yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes<br>echo &quot;设置kubelet开机启动&quot;<br>sudo systemctl enable --now kubelet<br><br><br>echo &quot;--------------------step-3 使用kubeadmin引导集群， 下载各个机器需要的镜像-------------------------&quot;<br>sudo tee ./images.sh &lt;&lt;-&#x27;EOF&#x27;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>images=(<br>kube-apiserver:v1.20.9<br>kube-proxy:v1.20.9<br>kube-controller-manager:v1.20.9<br>kube-scheduler:v1.20.9<br>coredns:1.7.0<br>etcd:3.4.13-0<br>pause:3.2<br>)<br>for imageName in $&#123;images[@]&#125; ; do<br>docker pull registry.aliyuncs.com/google_containers/$imageName<br>done<br>EOF<br>   <br>chmod +x ./images.sh &amp;&amp; ./images.sh<br><br>echo &quot;所有机器添加master域名映射&quot;<br>echo &quot;172.20.10.2  cluster-endpoint&quot; &gt;&gt; /etc/hosts<br>echo &quot;172.20.10.2  master&quot; &gt;&gt; /etc/hosts<br>echo &quot;172.20.10.4  slave&quot; &gt;&gt; /etc/hosts<br><br><br>current_hostname=$(hostname)<br><br>if [ &quot;$&#123;current_hostname&#125;&quot;x = &quot;master&quot;x ];then<br>echo &quot;主节点初始化&quot;<br>kubeadm init \<br>--apiserver-advertise-address=172.20.10.2 \<br>--control-plane-endpoint=cluster-endpoint \<br>--image-repository registry.aliyuncs.com/google_containers \<br>--kubernetes-version v1.20.9 \<br>--service-cidr=10.96.0.0/16 \<br>--pod-network-cidr=192.168.0.0/16<br><br>echo &quot;设置kube config&quot;<br>mkdir -p $HOME/.kube<br>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config<br><br>echo &quot;安装网络插件&quot;<br>curl https://docs.projectcalico.org/v3.20/manifests/calico.yaml -O<br>kubectl apply -f calico.yaml<br><br>echo &quot;请在work节点执行kubeadmin join命令加入节点&quot;<br>fi<br><br><br></code></pre></td></tr></table></figure><h2 id="4-主节点执行脚本进行初始化集群"><a href="#4-主节点执行脚本进行初始化集群" class="headerlink" title="4.  主节点执行脚本进行初始化集群"></a>4.  主节点执行脚本进行初始化集群</h2><p><code>sh k8s-install.sh master</code></p><h2 id="5-从节点执行脚本初始化集群，并加入主节点的集群-执行主节点初始化结果，有个命令，拷贝过来，在从节点初始化后执行"><a href="#5-从节点执行脚本初始化集群，并加入主节点的集群-执行主节点初始化结果，有个命令，拷贝过来，在从节点初始化后执行" class="headerlink" title="5.  从节点执行脚本初始化集群，并加入主节点的集群(执行主节点初始化结果，有个命令，拷贝过来，在从节点初始化后执行)"></a>5.  从节点执行脚本初始化集群，并加入主节点的集群(执行主节点初始化结果，有个命令，拷贝过来，在从节点初始化后执行)</h2><p><code>sh k8s-install.sh slave</code></p><h1 id="5-安装nfs"><a href="#5-安装nfs" class="headerlink" title="5. 安装nfs"></a>5. 安装nfs</h1><h2 id="1-规划nfs节点"><a href="#1-规划nfs节点" class="headerlink" title="1.  规划nfs节点"></a>1.  规划nfs节点</h2><p>server节点: 172.20.10.2</p><p>client节点: 172.20.10.4</p><h2 id="2-准备安装脚本nfs-install-sh-可同时用于server端和client端"><a href="#2-准备安装脚本nfs-install-sh-可同时用于server端和client端" class="headerlink" title="2.  准备安装脚本nfs-install.sh, 可同时用于server端和client端"></a>2.  准备安装脚本nfs-install.sh, 可同时用于server端和client端</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">/bin/bash</span><br><br>echo &quot;安装依赖nfs-utils nfs-common：&quot;<br>yum install -y nfs-utils nfs-common<br><br>FILE_PATH=/nfs/data<br>SERVER_TYPE=$1<br><br>if [ &quot;$&#123;SERVER_TYPE&#125;&quot;x = &quot;server&quot;x ];then<br><span class="hljs-meta prompt_">#</span><span class="language-bash">nfs服务节点</span><br>echo &quot;$FILE_PATH *(insecure,rw,sync,no_root_squash)&quot; &gt; /etc/exports<br>mkdir -p /nfs/data<br>systemctl enable rpcbind --now<br>systemctl enable nfs-server --now<br>systemctl start rpcbind<br>systemctl start nfs-server<br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置生效</span><br>exportfs -r<br>fi<br><br>if [ &quot;$&#123;SERVER_TYPE&#125;&quot;x = &quot;client&quot;x ];then<br>    SERVER_IP=$2<br><span class="hljs-meta prompt_">#</span><span class="language-bash">nfs客户端节点</span><br>showmount -e $SERVER_IP<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span><br>mkdir -p $FILE_PATH<br>mount -t nfs $SERVER_IP:$FILE_PATH $FILE_PATH<br><span class="hljs-meta prompt_">#</span><span class="language-bash">验证挂载生效</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入一个测试文件</span><br>echo &quot;hello nfs server&quot; &gt; $FILE_PATH/example.txt<br>echo &quot;please to the nfs server of $SERVER_IP read $FILE_PATH/example.txt&quot;<br>fi<br><br></code></pre></td></tr></table></figure><h2 id="3-安装server端，执行脚本"><a href="#3-安装server端，执行脚本" class="headerlink" title="3. 安装server端，执行脚本"></a>3. 安装server端，执行脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>sh nfs-install.sh server<br><br></code></pre></td></tr></table></figure><h2 id="4-安装client端，指定server的ip地址，执行脚本"><a href="#4-安装client端，指定server的ip地址，执行脚本" class="headerlink" title="4. 安装client端，指定server的ip地址，执行脚本"></a>4. 安装client端，指定server的ip地址，执行脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>sh nfs-install.sh client 172.20.10.2<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell编程语法</title>
    <link href="/2023/12/09/shell/shell%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/12/09/shell/shell%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-bash文件的定义"><a href="#1-bash文件的定义" class="headerlink" title="1.bash文件的定义"></a>1.bash文件的定义</h1><p>告诉计算机使用哪种解释器，解释器有以下几种</p><p>#!&#x2F;bin&#x2F;bash</p><p>#!&#x2F;bin&#x2F;sh</p><p>#!&#x2F;usr&#x2F;bin&#x2F;env</p><p>#!&#x2F;usr&#x2F;bin&#x2F;python</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">/bin/bash表示使用bash解释器</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">/bin/sh表示使用sh解释器</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">脚本内容</span><br>echo $(cat /etc/profile)<br></code></pre></td></tr></table></figure><h1 id="2-shell文件的执行方式"><a href="#2-shell文件的执行方式" class="headerlink" title="2.shell文件的执行方式"></a>2.shell文件的执行方式</h1><ul><li><p>文件保存为xxx.sh</p></li><li><p>4种执行方式</p><ul><li><p>文件执行,有权限限制，需要先赋予执行权限，开启子进程执行</p><p><code>./xxx.sh</code></p></li><li><p>bash命令执行，解释器为bash，开启子进程执行</p><p>​<code>bash ./xxx.sh</code></p></li><li><p>sh命令执行,解释器为sh,开启子进程执行</p><p>​<code>sh ./xxx.sh</code></p></li><li><p>source命令(点命令)执行,不开启子进程(后台执行，终端关闭)</p><p>​<code>source ./xxx.sh</code> <code>. ./xxx.sh</code></p></li></ul></li></ul><h1 id="3-输入与输出"><a href="#3-输入与输出" class="headerlink" title="3.输入与输出"></a>3.输入与输出</h1><blockquote><blockquote><p>输出</p></blockquote></blockquote><ul><li>echo</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">原始内容直接输出，输出结果为shell</span><br>echo &quot;shell&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">转义输出,输出结果为hello world</span><br>echo -e &quot;hello\tworld&quot;<br><br></code></pre></td></tr></table></figure><ul><li>printf</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">格式化输出,输出结果为｜12｜</span><br>printf &quot;|%d|&quot; 12 <br></code></pre></td></tr></table></figure><blockquote><blockquote><p>输入</p></blockquote></blockquote><ul><li><p>read</p><ul><li>-p显示提示信息</li><li>-t设置超时时间</li><li>-n允许输入的字符长度</li><li>-r 支持读取\</li><li>-s不显示输入内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">输入3组字符串</span><br>read a b c<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置提示消息</span><br>read -p &quot;请输入内容：&quot; a<br><span class="hljs-meta prompt_">#</span><span class="language-bash">不显示输入的内容</span><br>read -s -p &quot;请输入密码：&quot; a<br></code></pre></td></tr></table></figure></li></ul><h1 id="4-管道命令（中竖线）-｜"><a href="#4-管道命令（中竖线）-｜" class="headerlink" title="4.管道命令（中竖线） ｜"></a>4.管道命令（中竖线） ｜</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">统计命令执行结果中数据的行数</span><br>ls -la | wc -l<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看所有服务监听的端口列表中包含sshd的</span><br>ss -nutlp | grep sshd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将输出的字符串作为参数，修改root的密码</span><br>echo &quot;123...&quot; | passwd --stdin root<br></code></pre></td></tr></table></figure><h1 id="5-输入与输出重定向（将执行结果保存到文件中）"><a href="#5-输入与输出重定向（将执行结果保存到文件中）" class="headerlink" title="5.输入与输出重定向（将执行结果保存到文件中）"></a>5.输入与输出重定向（将执行结果保存到文件中）</h1><ul><li>输出重定向</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将执行结果导出到文件，如果文件不存在，则创建，存在则覆盖内容</span><br>ls -la &gt; aaa.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将执行结果追加到文件的末尾，不覆盖文件</span><br>ls -la &gt;&gt;aaa.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">正确与错误信息输出的重定向</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">1.正确输出重定向</span><br>ls -la &gt;&gt; aaa.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">2.错误输出重定向</span><br>ls -la 2&gt;&gt;aaa.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">3.正确与错误输出重定向到不同的文件</span><br>ls -la &gt;&gt;aaa.txt 2&gt;&gt;bbb.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">4.正确与错误信息同时追加重定向到同一个文件中</span><br>ls -la &amp;&gt;&gt;aaa.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">5.将错误输出重定向到正确输出</span><br>ls -la  &gt;aaa.txt 2&gt;&amp;1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">6.将正确输出重定向到错误输出</span><br>ls -la  &gt;aaa.txt 1&gt;&gt;&amp;2<br><br></code></pre></td></tr></table></figure><ul><li>输入重定向</li></ul><p>使用&lt;。&lt;后面跟一个文件名。将数据内容重定向传递给前面的一个命令，作为命令的输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">非交互的执行命令.使用脚本自动发送邮件，从文件中读取参数</span><br>mail -s warning root@localhosts &lt; /etc/hosts<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用&lt;&lt;就可以让脚本不需要依赖文件即可独立运行</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">语法格式</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">命令 &lt;&lt; 分隔符</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">内容</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">分隔符</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">cat</span>通过&lt;&lt;读取数据，再通过输出重定向将数据导出到文件中</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>cat &gt; aaa.txt &lt;&lt; HERE<br>this is content<br>HERE<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">不能屏蔽tab键，缩进作为内容的一部分被输出，并传递给程序</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>cat &gt; aaa.txt &lt;&lt; HERE<br>this is content<br>HERE<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用&lt;&lt;-可以忽略掉数据内容及分隔符前的tab键，不传递给程序</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>cat &gt; aaa.txt &lt;&lt;- HERE<br>this is content<br>HERE<br><br></code></pre></td></tr></table></figure><h1 id="6-变量与符号的使用"><a href="#6-变量与符号的使用" class="headerlink" title="6.变量与符号的使用"></a>6.变量与符号的使用</h1><p>更新中…</p>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义密钥生成自签名SSL证书</title>
    <link href="/2023/12/09/cert/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DSSL%E8%AF%81%E4%B9%A6/"/>
    <url>/2023/12/09/cert/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DSSL%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="生成SSL证书"><a href="#生成SSL证书" class="headerlink" title="生成SSL证书"></a>生成SSL证书</h2><ul><li><p>生成RSA密钥：需要设置密码，后面的操作都需要使用这个密码；执行命令：<br> localssl.key由自己定义<br><code>openssl genrsa -des3 -out D:/ssl/localssl.key 2048</code></p></li><li><p>拷贝一个不需要密码的密钥<br><code>openssl rsa -in D:/ssl/localssl.key -out D:/ssl/localssl_nopass.key</code></p></li><li><p>生成一个证书请求, 填写证书信息<br><code>openssl rsa -in D:/ssl/localssl.key -out D:/ssl/localssl_nopass.key</code></p></li><li><p>用上面的密钥和CSR对进行证书签名,生成证书文件(days是证书有效期)<br><code>openssl x509 -req -days 3650 -in D:/ssl/localssl.csr -signkey D:/ssl/localssl.key -out D:/ssl/localssl.crt</code></p></li></ul><h2 id="配置nginx的ssl，支持https"><a href="#配置nginx的ssl，支持https" class="headerlink" title="配置nginx的ssl，支持https"></a>配置nginx的ssl，支持https</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"> <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">listen</span>    <span class="hljs-number">443</span> ssl;<br>        <span class="hljs-attribute">server_name</span>  <span class="hljs-number">192.168.1.15</span>;<br><br>        <span class="hljs-attribute">ssl_certificate</span>  D:\ssl\localssl.crt;<br>        <span class="hljs-attribute">ssl_certificate_key</span>  D:\ssl\localssl_nopass.key;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cert</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSL自签名证书生成与配置(基于根证书)</title>
    <link href="/2023/12/09/cert/SSL%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6(%E5%9F%BA%E4%BA%8E%E6%A0%B9%E8%AF%81%E4%B9%A6)%E7%94%9F%E6%88%90%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/12/09/cert/SSL%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6(%E5%9F%BA%E4%BA%8E%E6%A0%B9%E8%AF%81%E4%B9%A6)%E7%94%9F%E6%88%90%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/mjy2wxy/p/15705680.html">如何让openssl生成的SSL证书被浏览器认可</a></p><blockquote><p>准备一台有openssl的服务器</p></blockquote><ul><li><h2 id="生成根证书"><a href="#生成根证书" class="headerlink" title="生成根证书"></a>生成根证书</h2><ul><li>生成命令如下，其中：&#x2F;C&#x3D;CN（国家缩写）&#x2F;ST&#x3D;（省份）&#x2F;L&#x3D;（城市）&#x2F;O&#x3D;（组织名称）：<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">openssl req -x509 -nodes -days <span class="hljs-number">3650</span> -<span class="hljs-keyword">new</span><span class="hljs-type">key</span> rsa:<span class="hljs-type">2048 -subj </span><br><span class="hljs-string">&quot;/C=CN/ST=ZheJiang/L=HangZhou/O=MJY&quot;</span> -keyout CA-<span class="hljs-keyword">private</span>.key <br>-out CA-certificate.crt -reqexts v3_req -extensions v3_ca<br></code></pre></td></tr></table></figure>这时会生成根证书文件CA-private.key、CA-certificate.crt</li></ul></li><li><h2 id="生成二级证书密钥"><a href="#生成二级证书密钥" class="headerlink" title="生成二级证书密钥"></a>生成二级证书密钥</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">openssl genrsa -<span class="hljs-keyword">out</span> <span class="hljs-keyword">private</span>.key <span class="hljs-number">2048</span><br></code></pre></td></tr></table></figure></li><li><h2 id="生成签名证书请求"><a href="#生成签名证书请求" class="headerlink" title="生成签名证书请求"></a>生成签名证书请求</h2><p>  <code>openssl req -new -key private.key -subj &quot;/C=CN/ST=ZheJiang/L=HangZhou/O=MJY/CN=127.0.0.1&quot; -sha256 -out private.csr</code><br>  其中ip部分根据自己实际情况修改</p></li><li><h2 id="创建ext文件，这个是为了将根证书签发机构加入到SAN扩展中，这样chrome就会认为是可信任的签发机构"><a href="#创建ext文件，这个是为了将根证书签发机构加入到SAN扩展中，这样chrome就会认为是可信任的签发机构" class="headerlink" title="创建ext文件，这个是为了将根证书签发机构加入到SAN扩展中，这样chrome就会认为是可信任的签发机构"></a>创建ext文件，这个是为了将根证书签发机构加入到SAN扩展中，这样chrome就会认为是可信任的签发机构</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#vim private.ext</span><br><span class="hljs-comment">#复制如下内容到private.ext文件中</span><br><br><span class="hljs-section">[ req ]</span><br><span class="hljs-attr">default_bits</span> = <span class="hljs-number">1024</span> distinguished_name = req_distinguished_name<br><span class="hljs-attr">req_extensions</span> = san<br><span class="hljs-attr">extensions</span> = san<br><span class="hljs-section">[ req_distinguished_name ]</span><br><span class="hljs-attr">countryName</span> = CN<br><span class="hljs-attr">stateOrProvinceName</span> = Definesys<br><span class="hljs-attr">localityName</span> = Definesys<br><span class="hljs-attr">organizationName</span> = Definesys<br><span class="hljs-section">[SAN]</span><br><span class="hljs-attr">authorityKeyIdentifier</span>=keyid,issuer<br><span class="hljs-attr">basicConstraints</span>=CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">keyUsage</span> = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment<br><span class="hljs-attr">subjectAltName</span> = IP:<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> <span class="hljs-comment">#其中ip后内容，改成自己需要的ip地址（服务器ip或者域名）  </span><br><span class="hljs-comment">#最后使用 :wq 保存退出</span><br></code></pre></td></tr></table></figure></li><li><h2 id="生成CA证书"><a href="#生成CA证书" class="headerlink" title="生成CA证书"></a>生成CA证书</h2><p><code>openssl x509 -req -days 3650 -in private.csr -CA CA-certificate.crt -CAkey CA-private.key -CAcreateserial -sha256 -out private.crt -extfile private.ext -extensions SAN</code></p></li></ul><p>生成结果如下：<br><img src="/images/cert/chrome-cert-1.png" alt="输入图片描述"></p><p>将证书配置到nginx<br><img src="/images/cert/chrome-cert-2.png" alt="输入图片描述"></p><p>客户端将CA-certificate.crt安装到受信任的颁发机构，重启浏览器访问，就发现不安全的标识已经没了<br><img src="/images/cert/chrome-cert-3.png" alt="输入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cert</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾收集算法</title>
    <link href="/2023/12/09/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <url>/2023/12/09/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p><p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法。</strong></p><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p><p>缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</p><blockquote><p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。<br>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</p></blockquote><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏</p><p><img src="/images/jvm/image-20200712102205795.png" alt="image-20200712102205795"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>我们使用一个案例来测试Java中是否采用的是引用计数算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 引用计数算法测试</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-12-10:26</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCountGC</span> &#123;<br>    <span class="hljs-comment">// 这个成员属性的唯一作用就是占用一点内存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] bigSize = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">5</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>    <span class="hljs-comment">// 引用</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RefCountGC</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefCountGC</span>();<br>        <span class="hljs-type">RefCountGC</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefCountGC</span>();<br>        obj1.reference = obj2;<br>        obj2.reference = obj1;<br>        obj1 = <span class="hljs-literal">null</span>;<br>        obj2 = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span><br>        System.gc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">15490</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">15490</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0061980</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.36</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">8</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">672</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">672</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3479</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3479</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0045983</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-variable">Heap</span><br> <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">655</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000770a00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000007c0000000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">65536</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b5a3ee8</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">10752</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">10752</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000770a00000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">672</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1e00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000006cc900000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1e00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1ea8070</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006cc900000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3486</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4496</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><br>  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">385</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">388</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span><br></code></pre></td></tr></table></figure><p>我们能够看到，上述进行了GC收集的行为，将上述的新生代中的两个对象都进行回收了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PSYoungGen</span>: <span class="hljs-number">15490</span>K-&gt;<span class="hljs-number">808</span>K(<span class="hljs-number">76288</span>K)] <span class="hljs-number">15490</span>K-&gt;<span class="hljs-number">816</span>K(<span class="hljs-number">251392</span>K)<br></code></pre></td></tr></table></figure><p>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p><p><img src="/images/jvm/image-20200712103230349.png" alt="image-20200712103230349"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。Python如何解决循环引用？</p><blockquote><p>手动解除：很好理解，就是在合适的时机，解除引用关系。<br>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</p></blockquote><h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>可达性分析算法：也可以称为 根搜索算法、追踪性垃圾收集</p><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p><p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p><p>基本思路：</p><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><img src="/images/jvm/image-20200712104149246.png" alt="image-20200712104149246"></p><p>官场上的裙带关系，可达性分析在人类关系网中</p><p><img src="/images/jvm/image-20200712104312406.png" alt="image-20200712104312406"></p><h3 id="GC-Roots可以是哪些？"><a href="#GC-Roots可以是哪些？" class="headerlink" title="GC Roots可以是哪些？"></a>GC Roots可以是哪些？</h3><ul><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象<ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（string Table）里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p><img src="/images/jvm/image-20200712104622677.png" alt="image-20200712104622677"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致GC进行时必须“stop The World”的一个重要原因。</p><p>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p><h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p><p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li>在finalize（）时可能会导致对象复活。</li><li>finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。<ul><li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ul></li><li>一个糟糕的finalize（）会严重影响Gc的性能。</li></ul><p>从功能上来说，finalize（）方法与c++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于C++中的析构函数。</p><p>由于finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态。</p><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</li><li>不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong>。</li></ul><p>以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ul><li><p>如果对象objA到GC Roots没有引用链，则进行第一次标记。</p></li><li><p>进行筛选，判断此对象是否有必要执行finalize（）方法</p><ul><li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li><li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li></ul></li></ul><p><img src="/images/jvm/image-20200712110411885.png" alt="image-20200712110411885"></p><p>上图就是我们看到的Finalizer线程</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>我们使用重写 finalize()方法，然后在方法的内部，重写将其存放到GC Roots中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试Object类中finalize()方法</span><br><span class="hljs-comment"> * 对象复活场景</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-12-11:06</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CanReliveObj</span> &#123;<br>    <span class="hljs-comment">// 类变量，属于GC Roots的一部分</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CanReliveObj canReliveObj;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-built_in">super</span>.finalize();<br>        System.out.println(<span class="hljs-string">&quot;调用当前类重写的finalize()方法&quot;</span>);<br>        canReliveObj = <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        canReliveObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanReliveObj</span>();<br>        canReliveObj = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        System.out.println(<span class="hljs-string">&quot;-----------------第一次gc操作------------&quot;</span>);<br>        <span class="hljs-comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;-----------------第二次gc操作------------&quot;</span>);<br>        canReliveObj = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        <span class="hljs-comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后运行结果</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">-----------------第一次gc操作------------</span><br>调用当前类重写的finalize()方法<br>obj <span class="hljs-keyword">is</span> still alive<br><span class="hljs-comment">-----------------第二次gc操作------------</span><br>obj <span class="hljs-keyword">is</span> dead<br></code></pre></td></tr></table></figure><p>在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</p><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id="MAT是什么？"><a href="#MAT是什么？" class="headerlink" title="MAT是什么？"></a>MAT是什么？</h3><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p><p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p><p>大家可以在<a href="http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BD%BF%E7%94%A8MAT">http://www.eclipse.org/mat/下载并使用MAT</a></p><h3 id="命令行使用-jmap"><a href="#命令行使用-jmap" class="headerlink" title="命令行使用 jmap"></a>命令行使用 jmap</h3><p><img src="/images/jvm/image-20200712112026317.png" alt="image-20200712112026317"></p><h3 id="使用JVIsualVM"><a href="#使用JVIsualVM" class="headerlink" title="使用JVIsualVM"></a>使用JVIsualVM</h3><p>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</p><p>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）。</p><p>在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。</p><p>右击这个节点选择save as（另存为）即可将heap dump保存到本地。</p><h3 id="使用MAT打开Dump文件"><a href="#使用MAT打开Dump文件" class="headerlink" title="使用MAT打开Dump文件"></a>使用MAT打开Dump文件</h3><p>打开后，我们就可以看到有哪些可以作为GC Roots的对象</p><p><img src="/images/jvm/image-20200712112512720.png" alt="image-20200712112512720"></p><p>里面我们能够看到有一些常用的Java类，然后Thread线程。</p><h3 id="JProfiler的GC-Roots溯源"><a href="#JProfiler的GC-Roots溯源" class="headerlink" title="JProfiler的GC Roots溯源"></a>JProfiler的GC Roots溯源</h3><p>我们在实际的开发中，一般不会查找全部的GC Roots，可能只是查找某个对象的整个链路，或者称为GC Roots溯源，这个时候，我们就可以使用JProfiler</p><p><img src="/images/jvm/image-20200712113256075.png" alt="image-20200712113256075"></p><h3 id="如何判断什么原因造成OOM"><a href="#如何判断什么原因造成OOM" class="headerlink" title="如何判断什么原因造成OOM"></a>如何判断什么原因造成OOM</h3><p>当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存溢出排查</span><br><span class="hljs-comment"> * -Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-12-14:56</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOOM</span> &#123;<br>    <span class="hljs-comment">// 创建1M的文件</span><br>    <span class="hljs-type">byte</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;HeapOOM&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapOOM</span>());<br>                count++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.getStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;count:&quot;</span> + count);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError将出错时候的dump文件输出</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span><br></code></pre></td></tr></table></figure><p>我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象</p><p><img src="/images/jvm/image-20200712150229048.png" alt="image-20200712150229048"></p><p>然后我们通过线程，还能够定位到哪里出现OOM</p><p><img src="/images/jvm/image-20200712150303710.png" alt="image-20200712150303710"></p><h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p><ul><li>标记一清除算法（Mark-Sweep）</li><li>复制算法（copying）</li><li>标记-压缩算法（Mark-Compact）</li></ul><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ul><li><strong>标记</strong>：Collector从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>。一般是在对象的Header中记录为可达对象。<ul><li><strong>标记的是引用的对象，不是垃圾！！</strong></li></ul></li><li><strong>清除</strong>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p><img src="/images/jvm/image-20200712150935078.png" alt="image-20200712150935078"></p><h3 id="什么是清除？"><a href="#什么是清除？" class="headerlink" title="什么是清除？"></a>什么是清除？</h3><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p><p>关于空闲列表是在为对象分配内存的时候 提过</p><ul><li>如果内存规整<ul><li>采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>虚拟机需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="/images/jvm/image-20200712151916991.png" alt="image-20200712151916991"></p><p>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法</p><p><img src="/images/jvm/image-20200712152029615.png" alt="image-20200712152029615"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</p><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><p><img src="/images/jvm/image-20200712152847218.png" alt="image-20200712152847218"></p><h2 id="清除阶段：标记-整理算法"><a href="#清除阶段：标记-整理算法" class="headerlink" title="清除阶段：标记-整理算法"></a>清除阶段：标记-整理算法</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p><p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p><h3 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h3><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p><p><img src="/images/jvm/image-20200712153236508.png" alt="image-20200712153236508"></p><h3 id="标清和标整的区别"><a href="#标清和标整的区别" class="headerlink" title="标清和标整的区别"></a>标清和标整的区别</h3><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p><p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><h3 id="标整的优缺点"><a href="#标整的优缺点" class="headerlink" title="标整的优缺点"></a>标整的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p>综合我们可以找到，没有最好的算法，只有最合适的算法</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li>年轻代（Young Gen）</li></ul><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><ul><li>老年代（Tenured Gen）</li></ul><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>compact阶段的开销与存活对象的数据成正比。</li></ul><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理</strong>，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。<br>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p><img src="/images/jvm/image-20200712165318590.png" alt="image-20200712165318590"></p><h2 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h2><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>commit合并</title>
    <link href="/2023/12/09/git/commit%E5%90%88%E5%B9%B6/"/>
    <url>/2023/12/09/git/commit%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="如何将多个commit合并为一个commit"><a href="#如何将多个commit合并为一个commit" class="headerlink" title="如何将多个commit合并为一个commit"></a>如何将多个commit合并为一个commit</h2><blockquote><p>场景说明</p></blockquote><p>有时候，我们在本地提交代码时执行了多个无效的commit，比如因为多次扫描代码而产生的commit，这些commit不需要提交到origin。而最终提交到origin的commit只能有一个，因此，这时需要将多个commit合并为一个origin。</p><blockquote><p>详细操作</p></blockquote><h2 id="1-git-log-查看commitId-hash"><a href="#1-git-log-查看commitId-hash" class="headerlink" title="1 . git log 查看commitId(hash)"></a>1 . git log 查看commitId(hash)</h2><p><img src="/images/git/git_merge_1.png" alt="查看commitId"></p><h2 id="2-取origin的commitId作为原点，执行-git-rebase-i-commitId"><a href="#2-取origin的commitId作为原点，执行-git-rebase-i-commitId" class="headerlink" title="2 . 取origin的commitId作为原点，执行 git rebase -i [commitId]"></a>2 . 取origin的commitId作为原点，执行 <code>git rebase -i [commitId]</code></h2><p><img src="/images/git/git_merge_2.png" alt="picture2"></p><h2 id="3-进入rebase-vi界面，只保留第一行的pick，将其余的pick改为s，wq保存退出"><a href="#3-进入rebase-vi界面，只保留第一行的pick，将其余的pick改为s，wq保存退出" class="headerlink" title="3.进入rebase vi界面，只保留第一行的pick，将其余的pick改为s，wq保存退出"></a>3.进入rebase vi界面，只保留第一行的pick，将其余的pick改为s，wq保存退出</h2><p><img src="/images/git/git_merge_3.png" alt="picture3"></p><h2 id="4-退出后自动进入commit-message-edit界面，这时将其他提交的message注释-wq后退出"><a href="#4-退出后自动进入commit-message-edit界面，这时将其他提交的message注释-wq后退出" class="headerlink" title="4.退出后自动进入commit message edit界面，这时将其他提交的message注释,wq后退出"></a>4.退出后自动进入commit message edit界面，这时将其他提交的message注释,wq后退出</h2><h2 id="5-在idea中查看git-log"><a href="#5-在idea中查看git-log" class="headerlink" title="5.在idea中查看git log"></a>5.在idea中查看git log</h2><p><img src="/images/git/git_merge_4.png" alt="picture4"></p><h2 id="6-执行git-push-操作"><a href="#6-执行git-push-操作" class="headerlink" title="6.执行git push 操作"></a>6.执行git push 操作</h2><p><img src="/images/git/git_merge_5.png" alt="picture5"></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象实例化: 内存布局与访问定位</title>
    <link href="/2023/12/03/jvm/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
    <url>/2023/12/03/jvm/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="对象实例化内存布局与访问定位"><a href="#对象实例化内存布局与访问定位" class="headerlink" title="对象实例化内存布局与访问定位"></a>对象实例化内存布局与访问定位</h1><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ul><li>对象在JVM中是怎么存储的？</li><li>对象头信息里面有哪些东西？</li><li>Java对象头有什么？</li></ul><p>从对象创建的方式 和 步骤开始说</p><p><img src="/images/jvm/image-20200709095356247.png" alt="image-20200709095356247"></p><h3 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h3><ul><li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li><li>使用序列化：序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ul><h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p><h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li><p>如果内存规整：指针碰撞</p></li><li><p>如果内存不规整</p><ul><li>虚拟表需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul><li>在Eden区给每个线程分配一块区域</li></ul></li></ul><h3 id="初始化分配到的内存"><a href="#初始化分配到的内存" class="headerlink" title="初始化分配到的内存"></a>初始化分配到的内存</h3><p>给对象属性赋值的操作</p><ul><li><p>属性的默认初始化</p></li><li><p>显示初始化</p></li><li><p>代码块中的初始化</p></li><li><p>构造器初始化</p></li><li><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p></li></ul><h3 id="设置对象的对象头"><a href="#设置对象的对象头" class="headerlink" title="设置对象的对象头"></a>设置对象的对象头</h3><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h3 id="执行init方法进行初始化"><a href="#执行init方法进行初始化" class="headerlink" title="执行init方法进行初始化"></a>执行init方法进行初始化</h3><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><h3 id="对象实例化的过程"><a href="#对象实例化的过程" class="headerlink" title="对象实例化的过程"></a>对象实例化的过程</h3><ul><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ul><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="/images/jvm/image-20200709151033237.png" alt="image-20200709151033237"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针</p><blockquote><p>如果是数组，还需要记录数组的长度</p></blockquote><h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>翩向时间戳</li></ul><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</p><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/images/jvm/image-20200709152801713.png" alt="image-20200709152801713"></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p><img src="/images/jvm/image-20200709164149920.png" alt="image-20200709164149920"></p><h3 id="对象访问的两种方式"><a href="#对象访问的两种方式" class="headerlink" title="对象访问的两种方式"></a>对象访问的两种方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><img src="/images/jvm/image-20200709164342002.png" alt="image-20200709164342002"></p><p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p><h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><p><img src="/images/jvm/image-20200709164350466.png" alt="image-20200709164350466"></p><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java堆</title>
    <link href="/2023/12/03/jvm/java%E5%A0%86/"/>
    <url>/2023/12/03/jvm/java%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p><p><img src="/images/jvm/image-20200706195127740.png" alt="image-20200706195127740"></p><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p><ul><li>堆内存的大小是可以调节的。</li></ul><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p><blockquote><p>-Xms10m：最小堆内存</p><p>-Xmx10m：最大堆内存</p></blockquote><p>下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件</p><p><img src="/images/jvm/image-20200706200739392.png" alt="image-20200706200739392"></p><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><p>我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p><ul><li>因为还有一些对象是在栈上分配的</li></ul><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p><p><img src="/images/jvm/image-20200706201904057.png" alt="image-20200706201904057"></p><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>Young Generation Space 新生区  Young&#x2F;New   又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区 Old&#x2F;Tenure</li><li>Permanent Space永久区   Perm</li></ul><p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p><ul><li>Young Generation Space新生区  Young&#x2F;New  又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区  Old&#x2F;Tenure</li><li>Meta Space  元空间   Meta</li></ul><p>约定：新生区 -&gt; 新生代 -&gt; 年轻代   、  养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p><p><img src="/images/jvm/image-20200706203419496.png" alt="image-20200706203419496"></p><p>堆空间内部结构，JDK1.8之前从永久代  替换成 元空间</p><p><img src="/images/jvm/image-20200706203835403.png" alt="image-20200706203835403"></p><h2 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li><li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p><p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p><p>默认情况下</p><ul><li><p>初始内存大小：物理电脑内存大小&#x2F;64</p></li><li><p>最大内存大小：物理电脑内存大小&#x2F;4</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span><br><span class="hljs-comment"> *  -X：是jvm运行参数</span><br><span class="hljs-comment"> *  ms：memory start</span><br><span class="hljs-comment"> * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-06-20:44</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSpaceInitial</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 返回Java虚拟机中的堆内存总量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">initialMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-comment">// 返回Java虚拟机试图使用的最大堆内存</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        System.out.println(<span class="hljs-string">&quot;-Xms:&quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms:245M</span><br><span class="hljs-deletion">-Xmx:3614M</span><br></code></pre></td></tr></table></figure><p>如何查看堆内存的内存分配情况</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps </span> -&gt;  <span class="hljs-keyword">jstat </span>-gc 进程id<br></code></pre></td></tr></table></figure><p><img src="/images/jvm/image-20200706205756045.png" alt="image-20200706205756045"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure><p><img src="/images/jvm/image-20200706205821919.png" alt="image-20200706205821919"></p><h3 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h3><p><img src="/images/jvm/image-20200706205947535.png" alt="image-20200706205947535"></p><p><img src="/images/jvm/image-20200706210000461.png" alt="image-20200706210000461"></p><p>我们简单的写一个OOM例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OOM测试</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-06-21:11</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            list.add(<span class="hljs-number">999999999</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后设置启动参数</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx:10m</span><br></code></pre></td></tr></table></figure><p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p><p><img src="/images/jvm/image-20200706211652779.png" alt="image-20200706211652779"></p><h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul><li>生命周期短的，及时回收即可</li></ul></li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><p><img src="/images/jvm/image-20200707075847954.png" alt="image-20200707075847954"></p><p>下面这参数开发中一般不会调：</p><p><img src="/images/jvm/image-20200707080154039.png" alt="image-20200707080154039"></p><ul><li>Eden：From：to -&gt;  8:1:1</li><li>新生代：老年代  - &gt;  1 : 2</li></ul><p>配置新生代与老年代在堆结构的占比。</p><ul><li><p>默认-XX:NewRatio&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p></li><li><p>可以修改-XX:NewRatio&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p></li></ul><blockquote><p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p></blockquote><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio&#x3D;8</p><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p><p>可以使用选项”-Xmn”设置新生代最大内存大小</p><p>这个参数一般使用默认值就可以了。</p></blockquote><p><img src="/images/jvm/image-20200707084208115.png" alt="image-20200707084208115"></p><h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ul><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><p>可以设置参数：-Xx:MaxTenuringThreshold&#x3D; N进行设置</p><h3 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC &#x2F; Minor GC操作</p><p><img src="/images/jvm/image-20200707084714886.png" alt="image-20200707084714886"></p><p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p><p><img src="/images/jvm/image-20200707085232646.png" alt="image-20200707085232646"></p><p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象  晋升到 老年代中</p><p><img src="/images/jvm/image-20200707085737207.png" alt="image-20200707085737207"></p><h3 id="思考：幸存区区满了后？"><a href="#思考：幸存区区满了后？" class="headerlink" title="思考：幸存区区满了后？"></a>思考：幸存区区满了后？</h3><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p><p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p><blockquote><p>举例：以当兵为例，正常人的晋升可能是 ：  新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p><p>但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -&gt; 排长</p></blockquote><h3 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h3><p><img src="/images/jvm/image-20200707091058346.png" alt="image-20200707091058346"></p><h3 id="代码演示对象分配过程"><a href="#代码演示对象分配过程" class="headerlink" title="代码演示对象分配过程"></a>代码演示对象分配过程</h3><p>我们不断的创建大对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码演示对象创建过程</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-07-9:16</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapInstanceTest</span> &#123;<br>    <span class="hljs-type">byte</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">200</span>)];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        ArrayList&lt;HeapInstanceTest&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapInstanceTest</span>());<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后设置JVM参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms600m -Xmx600m<br></code></pre></td></tr></table></figure><p>然后cmd输入下面命令，打开VisualVM图形化界面</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jvisualvm</span><br></code></pre></td></tr></table></figure><p>然后通过执行上面代码，通过VisualGC进行动态化查看</p><p><img src="/images/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.gif" alt="垃圾回收"></p><p>最终，在老年代和新生代都满了，就出现OOM</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: Java heap space<br>at com<span class="hljs-selector-class">.atguigu</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-class">.chapter08</span><span class="hljs-selector-class">.HeapInstanceTest</span>.&lt;init&gt;(HeapInstanceTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">13</span>)<br>at com<span class="hljs-selector-class">.atguigu</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-class">.chapter08</span><span class="hljs-selector-class">.HeapInstanceTest</span><span class="hljs-selector-class">.main</span>(HeapInstanceTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><h3 id="常用的调优工具"><a href="#常用的调优工具" class="headerlink" title="常用的调优工具"></a>常用的调优工具</h3><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控  推荐~）</li><li>Jprofiler（推荐~）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li><li>新生代采用复制算法的目的：是为了减少内碎片</li></ul><h2 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h2><ul><li>Minor GC：新生代的GC</li><li>Major GC：老年代的GC</li><li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li></ul><blockquote><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p><p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p></blockquote><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（MinorGC&#x2F;YoungGC）：只是新生代的垃圾收集</li><li>老年代收集（MajorGC&#x2F;o1dGC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><blockquote><p>STW：stop the word</p></blockquote><p><img src="/images/jvm/image-20200707095606813.png" alt="image-20200707095606813"></p><h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p><p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li></ul><p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>触发Fu11GC执行的情况有如下五种：</p><ul><li>调用System.gc（）时，系统建议执行Fu11GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p><h3 id="GC-举例"><a href="#GC-举例" class="headerlink" title="GC 举例"></a>GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * GC测试</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-07-10:01</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mogu blog&quot;</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                list.add(a);<br>                a = a + a;<br>                i++;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.getStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置JVM启动参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms10m -Xmx10m -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><p>打印出的日志</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2038</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">500</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">2038</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">797</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.3532002</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.36</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2108</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">480</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">2405</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">1565</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0014069</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2288</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">6845</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">9133</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058675</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0002857</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5263</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5263</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058564</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-variable">Heap</span><br> <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">60</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">2048</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd0f138</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">5263</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">73</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffb23cf0</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3514</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4498</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><br>  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">388</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">390</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span><br>  <br>  <span class="hljs-variable">Exception</span> <span class="hljs-variable">in</span> <span class="hljs-variable">thread</span> <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">OutOfMemoryError</span><span class="hljs-operator">:</span> <span class="hljs-variable">Java</span> <span class="hljs-variable">heap</span> <span class="hljs-variable">space</span><br><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">util</span><span class="hljs-operator">.</span><span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">copyOfRange</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">3664</span><span class="hljs-punctuation">)</span><br><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-built_in">String</span><span class="hljs-operator">.&lt;</span><span class="hljs-variable">init</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">String</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">207</span><span class="hljs-punctuation">)</span><br><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">StringBuilder</span><span class="hljs-operator">.</span><span class="hljs-variable">toString</span><span class="hljs-punctuation">(</span><span class="hljs-variable">StringBuilder</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">407</span><span class="hljs-punctuation">)</span><br><span class="hljs-variable">at</span> <span class="hljs-variable">com</span><span class="hljs-operator">.</span><span class="hljs-variable">atguigu</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">chapter08</span><span class="hljs-operator">.</span><span class="hljs-variable">GCTest</span><span class="hljs-operator">.</span><span class="hljs-variable">main</span><span class="hljs-punctuation">(</span><span class="hljs-variable">GCTest</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">20</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p><h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p> 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><blockquote><p>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to，s0&#x2F;s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p></blockquote><p><img src="/images/jvm/image-20200707101511025.png" alt="image-20200707101511025"></p><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p><img src="/images/jvm/image-20200707101543871.png" alt="image-20200707101543871"></p><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden<ul><li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li></ul></li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li></ul></li></ul><p>空间分配担保： -Xx:HandlePromotionFailure</p><ul><li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li></ul><h2 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h2><h3 id="问题：堆空间都是共享的么？"><a href="#问题：堆空间都是共享的么？" class="headerlink" title="问题：堆空间都是共享的么？"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p><h3 id="为什么有TLAB？"><a href="#为什么有TLAB？" class="headerlink" title="为什么有TLAB？"></a>为什么有TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><h3 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p><p><img src="/images/jvm/image-20200707103547712.png" alt="image-20200707103547712"></p><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><h3 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><p><img src="/images/jvm/image-20200707104253530.png" alt="image-20200707104253530"></p><h2 id="小结：堆空间的参数设置"><a href="#小结：堆空间的参数设置" class="headerlink" title="小结：堆空间的参数设置"></a>小结：堆空间的参数设置</h2><ul><li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p></li><li><p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p></li><li><p>-Xms：初始堆空间内存（默认为物理内存的1&#x2F;64）</p></li><li><p>-Xmx：最大堆空间内存（默认为物理内存的1&#x2F;4）</p></li><li><p>-Xmn：设置新生代的大小。（初始值及最大值）</p></li><li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p></li><li><p>-XX:SurvivorRatio：设置新生代中Eden和S0&#x2F;S1空间的比例</p></li><li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p></li><li><p>-XX：+PrintGCDetails：输出详细的GC处理日志</p><ul><li>打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc</li></ul></li><li><p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p></li></ul><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul><li>如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则改为进行一次FullGC。</li><li>如果HandlePromotionFailure&#x3D;false，则改为进行一次Ful1 Gc。</li></ul></li></ul><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p><h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><h4 id="逃逸分析举例"><a href="#逃逸分析举例" class="headerlink" title="逃逸分析举例"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">my_method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">V</span>();<br>    <span class="hljs-comment">// use v</span><br>    <span class="hljs-comment">// ....</span><br>    v = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要StringBuffer sb不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的逃逸分析代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 逃逸分析</span><br><span class="hljs-comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-07-20:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EscapeAnalysis</span> &#123;<br><br>    <span class="hljs-keyword">public</span> EscapeAnalysis obj;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> EscapeAnalysis <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> obj == <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>():obj;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 为成员属性赋值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObj</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 引用成员变量的值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> getInstance();<br>        <span class="hljs-comment">// getInstance().XXX  发生逃逸</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li><li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>常见的栈上分配的场景</p><blockquote><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p></blockquote><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 栈上分配</span><br><span class="hljs-comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-07-20:23</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String phone;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackAllocation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>        <span class="hljs-comment">// 为了方便查看堆内存中对象个数，线程sleep</span><br>        Thread.sleep(<span class="hljs-number">10000000</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 未发生逃逸</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置JVM参数，表示未开启逃逸分析</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-title class_">Xmx1</span>G -<span class="hljs-title class_">Xms1</span>G -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:-DoEscapeAnalysis</span> -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure><p>运行结果，同时还触发了GC操作</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">花费的时间为：664 ms<br></code></pre></td></tr></table></figure><p>然后查看内存的情况，发现有大量的User存储在堆中</p><p><img src="/images/jvm/image-20200707203038615.png" alt="image-20200707203038615"></p><p>我们在开启逃逸分析</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-title class_">Xmx1</span>G -<span class="hljs-title class_">Xms1</span>G -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+DoEscapeAnalysis</span> -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure><p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">花费的时间为：5 ms<br></code></pre></td></tr></table></figure><p>在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失</p><p><img src="/images/jvm/image-20200707203441718.png" alt="image-20200707203441718"></p><h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p><p>例如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span>(hellis) &#123;<br>        System.out.println(hellis);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>System.out.println(hellis);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将其转换成字节码</p><p><img src="/images/jvm/image-20200707205634266.png" alt="image-20200707205634266"></p><h3 id="分离对象和标量替换"><a href="#分离对象和标量替换" class="headerlink" title="分离对象和标量替换"></a>分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>    alloc();<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> y;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Point</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-string">&quot;point.x&quot;</span> + point.x + <span class="hljs-string">&quot;;point.y&quot;</span> + point.y);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    System.out.println(<span class="hljs-string">&quot;point.x = &quot;</span> + x + <span class="hljs-string">&quot;; point.y=&quot;</span> + y);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p><h3 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations<br></code></pre></td></tr></table></figure><p>这里设置参数如下：</p><ul><li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li><li>参数-Xmx10m：指定了堆空间最大为10MB</li><li>参数-XX:+PrintGC：将打印Gc日志</li><li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。<br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p><p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序计数器</title>
    <link href="/2023/12/03/jvm/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <url>/2023/12/03/jvm/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p><p><img src="/images/jvm/image-20200705155551919.png" alt="image-20200705155551919"></p><p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p><p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="/images/jvm/image-20200705155728557.png" alt="image-20200705155728557"></p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>我们首先写一个简单的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**程序计数器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-05-16:01</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PCRegisterTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">0: bipush        10<br>2: istore_1<br>3: bipush        20<br>5: istore_2<br>6: iload_1<br>7: iload_2<br>8: iadd<br>9: istore_3<br>10: <span class="hljs-built_in">return</span><br></code></pre></td></tr></table></figure><p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了 <img src="/images/jvm/image-20200705161007423.png" alt="image-20200705161007423"></p><h2 id="使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="使用PC寄存器存储字节码指令地址有什么用呢？"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="/images/jvm/image-20200705161409533.png" alt="image-20200705161409533"></p><h2 id="PC寄存器为什么被设定为私有的？"><a href="#PC寄存器为什么被设定为私有的？" class="headerlink" title="PC寄存器为什么被设定为私有的？"></a>PC寄存器为什么被设定为私有的？</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><p><img src="/images/jvm/image-20200705161812542.png" alt="image-20200705161812542"></p><h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="/images/jvm/image-20200705161849557.png" alt="image-20200705161849557"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM_运行时数据区概述及线程</title>
    <link href="/2023/12/03/jvm/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/12/03/jvm/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="/images/jvm/image-20200705111640511.png" alt="image-20200705111640511"></p><p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><p><img src="/images/jvm/image-20200705111843003.png" alt="image-20200705111843003"></p><p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><p><img src="/images/jvm/image-20200705112036630.png" alt="image-20200705112036630"></p><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p><blockquote><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></blockquote><p>运行时数据区的完整图</p><p><img src="/images/jvm/image-20200705112416101.png" alt="image-20200705112416101"></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><img src="/images/jvm/image-20200705112601211.png" alt="image-20200705112601211"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p><h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|<br>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载子系统</title>
    <link href="/2023/12/03/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/12/03/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/images/jvm/image-20200705080719531.png" alt="image-20200705080719531"></p><p>完整图如下</p><p><img src="/images/jvm/image-20200705080911284.png" alt="image-20200705080911284"></p><p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p><ul><li>类加载器</li><li>执行引擎</li></ul><h2 id="类加载器子系统作用"><a href="#类加载器子系统作用" class="headerlink" title="类加载器子系统作用"></a>类加载器子系统作用</h2><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p><p><img src="/images/jvm/image-20200705081813409.png" alt="image-20200705081813409"></p><ul><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li><li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ul><p><img src="/images/jvm/image-20200705081913538.png" alt="image-20200705081913538"></p><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p>例如下面的一段简单的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 类加载子系统</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-05-8:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我已经被加载啦&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的加载过程是怎么样的呢?</p><p><img src="/images/jvm/image-20200705082255746.png" alt="image-20200705082255746"></p><p>完整的流程图如下所示</p><p><img src="/images/jvm/image-20200705082601441.png" alt="image-20200705082601441"></p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p>通过一个类的全限定名获取定义此类的二进制字节流</p><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><h3 id="加载class文件的方式"><a href="#加载class文件的方式" class="headerlink" title="加载class文件的方式"></a>加载class文件的方式</h3><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p><blockquote><p>工具：Binary Viewer查看</p></blockquote><p><img src="/images/jvm/image-20200705084038680.png" alt="image-20200705084038680"></p><p>如果出现不合法的字节码文件，那么将会验证不通过</p><p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p><p><img src="/images/jvm/image-20200705090237078.png" alt="image-20200705090237078"></p><p>安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p><p><img src="/images/jvm/image-20200705090328171.png" alt="image-20200705090328171"></p><h3 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备 Prepare"></a>准备 Prepare</h3><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-05-8:42</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloApp</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的变量a在准备阶段会赋初始值，但不是1，而是0。</p><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p><p>例如下面这段代码</p><h3 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析 Resolve"></a>解析 Resolve</h3><p>将常量池内的符号引用转换为直接引用的过程。</p><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>初始化阶段就是执行类构造器法<clinit>（）的过程。</p><p>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p><ul><li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li></ul><p>构造器方法中指令按语句在源文件中出现的顺序执行。</p><p><clinit>（）不同于类的构造器。（关联：构造器是虚拟机视角下的<init>（））若该类具有父类，JVM会保证子类的<clinit>（）执行前，父类的<clinit>（）已经执行完毕。</p><ul><li>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-05-8:47</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassInitTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        num = <span class="hljs-number">2</span>;<br>        number = <span class="hljs-number">20</span>;<br>        System.out.println(num);<br>        System.out.println(number);  <span class="hljs-comment">//报错，非法的前向引用</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ClassInitTest.num); <span class="hljs-comment">// 2</span><br>        System.out.println(ClassInitTest.number); <span class="hljs-comment">// 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于涉及到父类时候的变量赋值过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-05-9:06</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClinitTest1</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">static</span> &#123;<br>            A = <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> A;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(Son.b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">iconst_1<br>putstatic <span class="hljs-comment">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br>iconst_2<br>putstatic <span class="hljs-comment">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br><span class="hljs-built_in">return</span><br></code></pre></td></tr></table></figure><p>虚拟机必须保证一个类的<clinit>（）方法在多线程下被同步加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-05-9:14</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThreadTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 线程t1开始&quot;</span>);<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadThread</span>();<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 线程t2开始&quot;</span>);<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadThread</span>();<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThread</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 初始化当前类&quot;</span>);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码，输出结果为</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">线程<span class="hljs-built_in">t1</span>开始<br>线程<span class="hljs-built_in">t2</span>开始<br>线程<span class="hljs-built_in">t2</span> 初始化当前类<br></code></pre></td></tr></table></figure><p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p><p><img src="/images/jvm/image-20200705094149223.png" alt="image-20200705094149223"></p><p>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。</p><p>我们通过一个类，获取它不同的加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-05-9:47</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 获取系统类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">systemClassLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader);<br><br>        <span class="hljs-comment">// 获取其上层的：扩展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">extClassLoader</span> <span class="hljs-operator">=</span> systemClassLoader.getParent();<br>        System.out.println(extClassLoader);<br><br>        <span class="hljs-comment">// 试图获取 根加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bootstrapClassLoader</span> <span class="hljs-operator">=</span> extClassLoader.getParent();<br>        System.out.println(bootstrapClassLoader);<br><br>        <span class="hljs-comment">// 获取自定义加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoaderTest.class.getClassLoader();<br>        System.out.println(classLoader);<br>        <br>        <span class="hljs-comment">// 获取String类型的加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> String.class.getClassLoader();<br>        System.out.println(classLoader1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit">sun.misc.Launcher$AppClassLoader<span class="hljs-symbol">@18b4aac2</span><br>sun.misc.Launcher$ExtClassLoader<span class="hljs-symbol">@1540e19d</span><br><span class="hljs-literal">null</span><br>sun.misc.Launcher$AppClassLoader<span class="hljs-symbol">@18b4aac2</span><br><span class="hljs-literal">null</span> <br></code></pre></td></tr></table></figure><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul><li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME&#x2F;jre&#x2F;1ib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h3 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h3><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;1ib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h3 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h3><ul><li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。<br>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>用户自定义类加载器实现步骤：</p><ul><li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul><h3 id="查看根加载器所能加载的目录"><a href="#查看根加载器所能加载的目录" class="headerlink" title="查看根加载器所能加载的目录"></a>查看根加载器所能加载的目录</h3><p>刚刚我们通过概念了解到了，根加载器只能够加载 java &#x2F;lib目录下的class，我们通过下面代码验证一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-05-10:17</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;*********启动类加载器************&quot;</span>);<br>        <span class="hljs-comment">// 获取BootstrapClassLoader 能够加载的API的路径</span><br>        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();<br>        <span class="hljs-keyword">for</span> (URL url : urls) &#123;<br>            System.out.println(url.toExternalForm());<br>        &#125;<br><br>        <span class="hljs-comment">// 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Provider.class.getClassLoader();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的结果</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">*********启动类加载器************<br><span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/resources.jar<br><span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/rt.jar<br><span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/sunrsasign.jar<br><span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jsse.jar<br><span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jce.jar<br><span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/charsets.jar<br><span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jfr.jar<br><span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>classes<br><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p><img src="/images/jvm/image-20200705103516138.png" alt="image-20200705103516138"></p><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><p><img src="/images/jvm/image-20200705103636003.png" alt="image-20200705103636003"></p><p>获取ClassLoader的途径</p><ul><li>获取当前ClassLoader：clazz.getClassLoader()</li><li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li><li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li><li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="/images/jvm/image-20200705105151258.png" alt="image-20200705105151258"></p><h3 id="双亲委派机制举例"><a href="#双亲委派机制举例" class="headerlink" title="双亲委派机制举例"></a>双亲委派机制举例</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p><p><img src="/images/jvm/image-20200705105810107.png" alt="image-20200705105810107"></p><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="如何判断两个class对象是否相同"><a href="#如何判断两个class对象是否相同" class="headerlink" title="如何判断两个class对象是否相同"></a>如何判断两个class对象是否相同</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul><p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：王动使用和被动使用。<br>主动使用，又分为七种情况：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法I</li><li>反射（比如：Class.forName（”com.atguigu.Test”））</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：</li><li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
